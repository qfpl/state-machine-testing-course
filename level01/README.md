# Level 01 - Simple Commands

The first thing we're going to test is drink selection. The machine
can be switched between coffee, hot chocolate and tea, and we're going
to define commands for each operation. We'll then build the commands
up into a state machine test and walk through how it's wired into a
larger test suite.

The first thing we'll need is a model of the coffee machine. The model
for a test does not have to replicate the entire system perfectly; we
start small, capturing the things we understand as we build our
commands and observe their interactions. Open up
`level01/CoffeeMachineTests.hs`, where you'll find the following model
defined for you:

```haskell
data DrinkType = Coffee | HotChocolate | Tea
newtype Model (v :: Type -> Type) = Model DrinkType
```

Note that `Model` has a mysterious type parameter `v`, and to give the
_kind signature_ `Type -> Type` to `v` we've had turn on `{-# LANGUAGE
KindSignatures #-}` as GHC will not infer the correct kind
otherwise. You can get away with cargo-culting this for the moment,
but if you're the sort of person who needs to dig through the details,
check out the asides below:

<details>
  <summary>Kind Signatures?</summary>

  A _kind_ is the "type" of a type. The kind `Type` is the kind of
  types that can have values. Consider `Maybe` - its type argument
  must be a type that can have values, and it can have values once
  it's fully applied (like in `Maybe Int`), so its kind is `Type ->
  Type`. (You might have seen this written as `* -> *` in the past;
  `*` is now an alias for `Type`.)

  This means that our `Model` type takes one type argument of kind
  `Type -> Type`; something `Functor`-shaped.
</details>

<details>
  <summary>What's the type parameter used for?</summary>

  Hedgehog generates complete command sequences before it runs any
  commands, and not every command can be run at any time. Example: if
  your web service has commands that need administrator powers, you
  need to register an admin before you try running those commands, and
  you won't know what user ID will come back when you register an
  admin.

  This means that some generators need to know the results of previous
  actions. At the same time, you can't know what the exact values from
  previous actions, because the tests haven't run yet!

  Hedgehog solves this with a container type
  [`Var`](https://hackage.haskell.org/package/hedgehog/docs/Hedgehog.html#t:Var),
  which either holds the value that come from executing a previous
  command, or a symbolic placeholder. It does so using the types
  [`Symbolic`](https://hackage.haskell.org/package/hedgehog/docs/Hedgehog.html#t:Symbolic)
  and
  [`Concrete`](https://hackage.haskell.org/package/hedgehog/docs/Hedgehog.html#t:Concrete)
  . In the generation phase of the test, your model is a `Model
  Symbolic`, but once it starts executing it becomes a `Model
  Concrete` and you can pull out real values from the model.

  We explore this in detail as part of Level 06.
</details>

*****

Now that we have our model, we need to build some commands to act on
it. The core type to understand is
[`Command`](https://hackage.haskell.org/package/hedgehog/docs/Hedgehog.html#t:Command),
reproduced here with some type variables renamed:

```haskell
data Command g m (state :: (Type -> Type) -> Type) =
  forall input output.
  (HTraversable input, Show (input Symbolic), Typeable output) =>
  Command {
    -- | A generator which provides random arguments for a command. If the
    --   command cannot be executed in the current state, it should return
    --   'Nothing'.
    --
      commandGen ::
        state Symbolic -> Maybe (g (input Symbolic))

    -- | Executes a command using the arguments generated by 'commandGen'.
    --
    , commandExecute ::
        input Concrete -> m output

    -- | A set of callbacks which provide optional command configuration such
    --   as pre-condtions, post-conditions and state updates.
    --
    , commandCallbacks ::
        [Callback input output state]
    }
```

Here are some important things to understand about `Command`:

* When we pass our list of commands to `Hedgehog.Gen.sequential` (to
  generate the random sequences), we'll need `(MonadGen g, MonadTest
  m)`.

* We'll often need `MonadIO m` as well, so we can interact with the
  system being tested.

* `commandGen` can decline to return an `input` by returning
  `Nothing`. This can be faster than generating inputs and pruning
  them back with a `Require` callback.

* The kind of `state` matches the kind of our `Model` type from
  before.

* The `input` and `output` type variables are existential, so each
  `Command` can choose ones that make sense.

* The `input` type must be `HTraversable`, which we'll talk about
  soon.

* The list of callbacks will be explored later.

## Your first command

We're going to walk through a simple command to select coffee on the
machine. After that, you'll need to set up similar commands to select
hot chocolate and tea.

Our goal is to write a function of this type:

```haskell
cSetDrinkCoffee
  :: forall g m. (MonadGen g, MonadTest m, MonadIO m)
  -> C.Machine
  -> Command g m Model
```

`C.Machine` is our coffee machine type from the library, a `newtype`
wrapper around an `IORef`. Later, we will pass the same `C.Machine` to
all our `Command`-returning functions so the tests all operate on the
same thing. We're writing the `forall` explicitly so we can use `{-#
LANGUAGE ScopedTypeVariables #-}` and write `g` and `m` in type
signatures for helper functions.

To write `cSetDrinkCoffee`, we'll need to pick a type for the input, so
let's define one:

```haskell
data SetDrinkCoffee (v :: Type -> Type) = SetDrinkCoffee deriving Show
```

We know from the type of `Command` that we'll need a
[`HTraversable`](https://hackage.haskell.org/package/hedgehog/docs/Hedgehog.html#t:HTraversable)
instance, so let's look at the class definition now:

```haskell
class HTraversable t where
  htraverse :: Applicative f => (forall a. g a -> f (h a)) -> t g -> f (t h)
```

Hedgehog uses this class with `(g ~ Symbolic, h ~ Concrete)` to
convert `Symbolic` values to `Concrete` values inside inputs, so you
have the real values when you run the command sequence against the
real system. Because our type doesn't have any `Var`s in it, we can
ignore the function, and because we don't have any data in our input
type we can ignore that argument too:

```haskell
instance HTraversable SetDrinkCoffee where htraverse _ _ = pure SetDrinkCoffee
```

Now, let's write the bulk of the `cSetDrinkCoffee` function:

```haskell
cSetDrinkCoffee
  :: forall g m. (MonadGen g, MonadTest m, MonadIO m)
  => C.Machine
  -> Command g m Model
cSetDrinkCoffee mach = Command gen exec []
  where
    gen :: Model Symbolic -> Maybe (g (SetDrinkCoffee Symbolic))
    gen _ = Just $ pure SetDrinkCoffee

    exec :: SetDrinkCoffee Concrete -> m C.Drink
    exec _ = evalIO $ do
      C.coffee mach
      view C.drinkSetting <$> C.peek mach
```

Some things to notice:

* Our generation function can always run. Some generators won't always
  be runnable, and will return `Nothing`.

* The `C.Drink` in our `exec` function fixes our `output` type; this
  type will show up when we add callbacks.

* Our list of callbacks is empty. This is wrong, and we will fix it
  now.

## Adding Callbacks

The main thing we are missing is code to test that our command
actually worked. To add that, we need to look at the
[`Callback`](https://hackage.haskell.org/package/hedgehog/docs/Hedgehog.html#t:Callback)
type:

```haskell
data Callback input output state
  = Require (state Symbolic -> input Symbolic -> Bool)
  | Update (forall v. Ord1 v => state v -> input v -> Var output v -> state v)
  | Ensure (state Concrete -> state Concrete -> input Concrete -> output -> Test ())
```

The list of `Callbacks` in a `Command` is technically optional but in
practice you'll almost always use it. It is how we:

  - Assert preconditions on actions, which guarantees that shrunken
    command sequences stay valid,

  - Update our model as actions are performed, and

  - Assert postconditions on actions, checking that our system
    actually behaves correctly.

For our current situation, we need to do two things:

  - update the model with the new drink type (an `Update` callback), and
  - ensure that our command actually worked on the real system (an
    `Ensure` callback).

We know from the context that `state ~ Model`, `input ~ Model` and
`output ~ C.Drink`, so the callback constructors will have these
types:

  - `Update :: forall v. Ord1 v => Model v -> Model v -> Var C.Drink v -> Model v`
  - `Ensure :: Model Concrete -> Model Concrete -> Model Concrete -> C.Drink -> Test ()`

For `Update`, the `forall v.` ensures that our updates will work on
both `Concrete` and `Symbolic` values, but in this case our commands
are so simple that we can disregard all arguments and just return a
new `Model`.

For `Ensure`, we can disregard most of the arguments as well, except
for the final `C.Drink` argument. This came from the exec part of our
`Command`, and we use it to check that the real system's behavior
matches our model.

With type holes and a bit of patience, that gives us enough
information to build out three commands: one to set each drink type.

The next thing to do is walk through the `test-suite` component to
familiarise ourselves with the libraries, and make sure the state
machine tests are wired into the test suite.

We're using [`tasty`](https://hackage.haskell.org/package/tasty) to
define the test suite, and
[`tasty-hedgehog`](https://hackage.haskell.org/package/tasty-hedgehog)
to connect our tests to the Tasty `TestTree`. We've done this so
you'll know how to integrate hedgehog tests into your existing test
suite.

`level01/Main.hs` is the entry point for the test suite, and will stay
largely the same across levels. It defines a single `TestTree` which
imports the actual `stateMachineTests :: TestTree` from
`level01/CoffeeMachineTests.hs`.

The function `Hedgehog.Gen.sequential` turns a list of commands into a
generator for random sequences of sequential commands. This is what we
run to test our system. Note that the call to `C.reset` is _after_ the
`Gen.sequential` call: this is how we reset the model between tests.

# Your Task

Complete the definitions of `setDrinkHotChocolate` and `setDrinkTea`,
and define necessary types and `HTraversable` instances for these
commands. You'll retain more if you type out the other two commands by
hand, and use typed holes and a running `ghcid` session so you can
watch the types coming together.
